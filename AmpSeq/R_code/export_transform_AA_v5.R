# This code transforms AmpSeq data generated by the AmpSeq AA script (v5)
# into an Excel file that can be directly uploaded to the DoH's SharePoint.

library(tibble)
library(writexl)
library(reshape2)
library(RColorBrewer)
library(ggplot2)
library(lubridate)
library(dplyr)

# -----------------------------------------------------------------
# Summary table
# -----------------------------------------------------------------

# import Sample List file exported from Benchling
sample_info <- read.csv("Sample_List.csv")[-c(1), c(2,6,7,8,10,16)]

# set column names
colnames(sample_info) <- c("RNA_ID",
                           "DHHS SampleNo",
                           "Sample ID",
                           "DHHS SiteName",
                           "Retrieved",
                           "Mean Cq")

# -----------------------------------------------------------------

# import read_counts
read_counts <- read.table("read_counts.txt", sep = "\t", header = TRUE)[-c(1,2),]

# set column order
read_counts <- read_counts[, c("sample",
                               "filtered",
                               "BA2",
                               "BA275",
                               "CH11",
                               "XBC",
                               "XBB19",
                               "XBB116",
                               "EG51",
                               "HK3",
                               "BA286",
                               "HV1",
                               "DV71",
                               "GW511",
                               "JN1",
                               "FLiP")]

# ensure filtered read values are >0 so percentage calculations don't fail
read_counts$filtered <- read_counts$filtered + 1

# calculate percentages
read_counts[,c(4:ncol(read_counts))] <- round((read_counts[,c(4:ncol(read_counts))]/read_counts$filtered)*100, digits = 1)

# calculate Unassigned
read_counts$Unassigned <- 100 - rowSums(read_counts[,c(4:(ncol(read_counts)-1))])

# set column names
colnames(read_counts) <- c("RNA_ID",
                           "Filtered Reads",
                           "BA2",
                           "BA275",
                           "CH11",
                           "XBC",
                           "XBB19",
                           "XBB116",
                           "EG51",
                           "HK3",
                           "BA286",
                           "HV1",
                           "DV71",
                           "GW511",
                           "JN1",
                           "FLiP %",
                           "Unassigned")

# -----------------------------------------------------------------

# import snp_counts - column names will be offset
snp_counts <- read.table("snp_counts.txt", sep = "\t", header = TRUE, fill = TRUE, row.names = NULL)[-c(1,2),]
snp_counts <- snp_counts[,1:4]

# set column names
colnames(snp_counts) <- c("RNA_ID",
                          "Non-classified SNPs",
                          "Non-classified SNPs %",
                          "Detected SNPs")

# -----------------------------------------------------------------

# combine data
all_amp <- merge(sample_info, (merge(read_counts, snp_counts,by="RNA_ID")),by = "RNA_ID")

# remove NTC samples
all_amp <- all_amp[grep("NTC", all_amp$RNA_ID, invert = TRUE),]

# remove Non-Reportable samples
all_amp <- all_amp[grep("nr", all_amp$RNA_ID, invert = TRUE),]

# reset row numbers
rownames(all_amp) <- NULL

# -----------------------------------------------------------------

# set default technical column values
`Technical Notes` <- NA
`Sequencing QC` <- "Fail"

# add columns
all_amp <- cbind(all_amp, `Technical Notes`, `Sequencing QC`)

# insert technical note
all_amp$`Technical notes`[all_amp$`Filtered Reads` < 2000] <- "QC criteria not met (Filtered Reads â‰¥ 2k)"

# insert sequencing QC pass/fail comment
all_amp$`Sequencing QC`[is.na(all_amp$`Technical notes`)] <- "Pass"

# insert default Repeat Number
all_amp <- add_column(all_amp, `Repeat Number` = 5, .after = 1)

# insert Repeat Number for repeated samples (assumes samples are only ever repeated once)
all_amp$`Repeat Number`[substr(all_amp$RNA_ID, 9,12) != ""] <- 6

# -----------------------------------------------------------------

# DUPLICATE RULES:
# if both dupes fail, remove the 'neat' dupe
# if neither dupe fails, remove the 'neat' dupe
# if one dupe fails, remove the failed dupe

# get all duplicate sample names
dupenames <- substr(all_amp$RNA_ID[duplicated(substr(all_amp$RNA_ID,1,8))],1,8)

# get all duplicate indexes
alldupes <- vector("numeric", 0L)
if (length(dupenames) != 0) {
  for (i in 1:length(dupenames)) {
    alldupes <- c(which(substr(all_amp$RNA_ID,1,8) == dupenames[i]), alldupes)
  }
} else {
  print("No duplicates")
}

# get FAILED duplicate indexes
fails <- vector("numeric", 0L)
if (length(dupenames) != 0) {
  for (i in 1:length(dupenames)) {
    fails <- c(intersect(which(substr(all_amp$RNA_ID,1,8) == dupenames[i]), which(all_amp$`Sequencing QC` == "Fail")), fails)
  }
} else {
  print("No duplicates")
}

# get NEAT indexes (assumes all NEATs are duplicates)
neats <- vector("numeric", 0L)
if (length(dupenames) != 0) {
    neats <- which(substr(all_amp$RNA_ID,9,12) == "neat")
} else {
  print("No duplicates")
}

# where both duplicates have failed, remove the FAILED NEAT duplicate
if (length(dupenames) != 0) {
  all_amp <- all_amp[-(intersect(fails, neats)),]
} else {
  print("No duplicates")
}

# ------

# UPDATE INDEXES

# get all remaining duplicate sample names
dupenames <- substr(all_amp$RNA_ID[duplicated(substr(all_amp$RNA_ID,1,8))],1,8)

# get all remaining duplicate indexes
alldupes <- vector("numeric", 0L)
if (length(dupenames) != 0) {
  for (i in 1:length(dupenames)) {
    alldupes <- c(which(substr(all_amp$RNA_ID,1,8) == dupenames[i]), alldupes)
  }
} else {
  print("No duplicates")
}

# get remaining FAILED duplicate indexes
fails <- vector("numeric", 0L)
if (length(dupenames) != 0) {
  for (i in 1:length(dupenames)) {
    fails <- c(intersect(which(substr(all_amp$RNA_ID,1,8) == dupenames[i]), which(all_amp$`Sequencing QC` == "Fail")), fails)
  }
} else {
  print("No duplicates")
}

# get remaining NEAT indexes (assumes all NEATs are duplicates)
neats <- vector("numeric", 0L)
if (length(dupenames) != 0) {
  neats <- which(substr(all_amp$RNA_ID,9,12) == "neat")
} else {
  print("No duplicates")
}

# get remaining PASSED duplicate indexes
passes <- vector("numeric", 0L)
if (length(dupenames) != 0) {
  for (i in 1:length(dupenames)) {
    passes <- c(intersect(which(substr(all_amp$RNA_ID,1,8) == dupenames[i]), which(all_amp$`Sequencing QC` == "Pass")), passes)
  }
} else {
  print("No duplicates")
}

# where only one duplicate has failed, remove it
if (length(dupenames) != 0) {
  all_amp <- all_amp[-(setdiff(alldupes, passes)),]
} else {
  print("No duplicates")
}

# ------

# UPDATE INDEXES

# get all remaining duplicate sample names
dupenames <- substr(all_amp$RNA_ID[duplicated(substr(all_amp$RNA_ID,1,8))],1,8)

# get all remaining duplicate indexes
alldupes <- vector("numeric", 0L)
if (length(dupenames) != 0) {
  for (i in 1:length(dupenames)) {
    alldupes <- c(which(substr(all_amp$RNA_ID,1,8) == dupenames[i]), alldupes)
  }
} else {
  print("No duplicates")
}

# get remaining FAILED duplicate indexes
fails <- vector("numeric", 0L)
if (length(dupenames) != 0) {
  for (i in 1:length(dupenames)) {
    fails <- c(intersect(which(substr(all_amp$RNA_ID,1,8) == dupenames[i]), which(all_amp$`Sequencing QC` == "Fail")), fails)
  }
} else {
  print("No duplicates")
}

# get remaining NEAT indexes (assumes all NEATs are duplicates)
neats <- vector("numeric", 0L)
if (length(dupenames) != 0) {
  neats <- which(substr(all_amp$RNA_ID,9,12) == "neat")
} else {
  print("No duplicates")
}

# get remaining PASSED duplicate indexes
passes <- vector("numeric", 0L)
if (length(dupenames) != 0) {
  for (i in 1:length(dupenames)) {
    passes <- c(intersect(which(substr(all_amp$RNA_ID,1,8) == dupenames[i]), which(all_amp$`Sequencing QC` == "Pass")), passes)
  }
} else {
  print("No duplicates")
}

# where both duplicates have PASSED, remove the PASSED NEAT duplicate
if (length(dupenames) != 0) {
  all_amp <- all_amp[-(intersect(passes, neats)),]
} else {
  print("No duplicates")
}

# -----------------------------------------------------------------

# insert Recommendations
all_amp$Recommendations[all_amp$`Sequencing QC` == "Fail" & all_amp$`Mean Cq` > 37] <- "Sequencing failure - does not meet criteria for repeat testing (Cq < 37)"
all_amp$Recommendations[all_amp$`Sequencing QC` == "Fail" & all_amp$`Mean Cq` <= 37] <- "Sequencing failure - repeat sequencing"
all_amp$Recommendations[all_amp$`Sequencing QC` == "Fail" & all_amp$`Repeat Number` > 5] <- "Unable to sequence after multiple attempts"
all_amp$Recommendations[all_amp$`Sequencing QC` == "Pass" & all_amp$`Repeat Number` > 5] <- "Sample sequenced successfully upon repeat"
all_amp$Recommendations[all_amp$`Sequencing QC` == "Pass" & all_amp$`Mean Cq` > 37] <- "Cq is indicative of inhibition or low viral load which may adversely affect the quality and accuracy of the results"
all_amp$Recommendations[all_amp$`Sequencing QC` == "Pass" & all_amp$`Mean Cq` > 37 & all_amp$`Repeat Number` > 5] <- "Sample sequenced successfully upon repeat. Cq is indicative of inhibition or low viral load which may adversely affect the quality and accuracy of the results"

# insert repeat comment
all_amp$Repeat <- NA # prevents cells being filled with value from Repeat Number column (column naming conflict?)
all_amp$Repeat[all_amp$Recommendations == "Sequencing failure - repeat sequencing"] <- "Requested"

# insert Questionable comments
all_amp$Questionable[all_amp$`Sequencing QC` == "Fail" & all_amp$`Mean Cq` > 37] <- "Final - will not be repeated"
all_amp$Questionable[all_amp$`Sequencing QC` == "Fail" & all_amp$`Repeat Number` > 5] <- "Final - will not be repeated"
all_amp$Questionable[all_amp$Recommendations == "Sequencing failure - repeat sequencing"] <- "Pending - repeat requested"
all_amp$Questionable[all_amp$`Sequencing QC` == "Pass" & all_amp$`Repeat Number` > 5] <- "Final - after repeat"

# reorder columns
all_amp <- all_amp[,c("RNA_ID",
                      "Repeat Number",
                      "DHHS SampleNo",
                      "Sample ID",
                      "DHHS SiteName",
                      "Retrieved",
                      "Mean Cq",
                      "Filtered Reads",
                      "Sequencing QC",
                      "BA2",
                      "BA275",
                      "CH11",
                      "XBC",
                      "XBB19",
                      "XBB116",
                      "EG51",
                      "HK3",
                      "BA286",
                      "HV1",
                      "DV71",
                      "GW511",
                      "JN1",
                      "Unassigned",
                      "FLiP %",
                      "Non-classified SNPs",
                      "Non-classified SNPs %",
                      "Detected SNPs",
                      "Technical notes",
                      "Repeat",
                      "Recommendations",
                      "Questionable")]

# -----------------------------------------------------------------
# Identify the 10 most abundant "Unassigned"
# -----------------------------------------------------------------

# import other count data
other_counts <- read.table(file = "other_counts.txt", header = TRUE)[-c(1,2),]
colnames(other_counts)[1] <- c("RNA_ID")
other_counts_only <- ncol(other_counts)

# retain only the reportable samples
other_counts <- merge(other_counts, all_amp, by = "RNA_ID")
other_counts <- other_counts[,1:other_counts_only]

# get identities of reads described in top10_other_snps.txt from
# https://cov-spectrum.org/explore/World/AllSamples/AllTimes/
colnames(other_counts)[3] <- c("XBB")
colnames(other_counts)[4] <- c("JD.1.1")
colnames(other_counts)[5] <- c("HV.1 -V445P -F456L -N460K -F490S")
colnames(other_counts)[6] <- c("FL.20.1")
colnames(other_counts)[7] <- c("XBC")
colnames(other_counts)[8] <- c("JF.1")
colnames(other_counts)[9] <- c("HK.3 +L452Q")
colnames(other_counts)[10] <- c("HK.3 -F490S")
colnames(other_counts)[11] <- c("FL.1.5.1 V445P>S")
colnames(other_counts)[12] <- c("HV.1 -V455P -F456L -N460K")

# # sum values from common columns
# other_counts$XBB <- other_counts[,5] + other_counts[,6]
# 
# # remove redundant common columns
# other_counts <- other_counts[,-c(5,6)]

# calculate percentages
other_counts[,c(3:ncol(other_counts))] <- round((other_counts[,c(3:ncol(other_counts))]/other_counts$filtered)*100, digits = 1)

# calculate percentages of 'Other' - the percentage not accounted for by the binned count data or the identified Unassigned count data
read_counts_only <- ncol(read_counts)
read_counts <- merge(read_counts, all_amp, by = "RNA_ID")
read_counts <- read_counts[,1:read_counts_only]
other_counts$Other <- read_counts$Unassigned - rowSums(other_counts[,3:ncol(other_counts)])

# -----------------------------------------------------------------

# shorten sample names in the final data-frames
all_amp$RNA_ID <- substr(all_amp$RNA_ID,1,8)
other_counts$RNA_ID <- substr(other_counts$RNA_ID,1,8)

# export data
write_xlsx((merge((all_amp[,c(1,2,9,23)]), (other_counts[,c(1,3:ncol(other_counts))]), by = "RNA_ID")),
           "unassigned_sheet.xlsx")

write_xlsx(all_amp, "summary_sheet.xlsx")

# -----------------------------------------------------------------
# "Unassigned" bar chart
# -----------------------------------------------------------------

# retain only PASS samples
other_counts <- other_counts[other_counts$filtered >= 2000,]

# convert data to long format (exclude "filtered" column)
other_long <- reshape2::melt(other_counts[,-2])

# # legend title
# legend_title <- "Description"

# create colour palette
nb.cols <- length(c(3:ncol(other_counts))) # number of colours needed
mycolors <- colorRampPalette(brewer.pal(9, "Set1"))(nb.cols)

other_long %>%
  ggplot(aes(fill=variable, y=value, x=RNA_ID)) +
  geom_bar(position="stack",stat="identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle=90, vjust=0.5, hjust=1)) +
  ylab("Relative Abundance (%)") +
  xlab("Sample") +
  scale_fill_manual(name=NULL, values=mycolors)
  # scale_fill_manual(legend_title, values=mycolors)

ggsave("Unassigned_BarChart.pdf", width = 297, height = 210, units = "mm")

# -----------------------------------------------------------------
